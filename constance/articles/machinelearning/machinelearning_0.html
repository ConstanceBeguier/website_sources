<h1>Introduction</h1>

<p>Dans cet article, nous allons présenter rapidement le fonctionnement des principaux algorithmes de machine learning.</p>

<br>

<h4>Types de machine learning</h4>

<p>Nous allons tout d'abord présenter les différents types de machine learning :
<ul>
	<li>l'apprentissage supervisé</li>
	<li>l'apprentissage non supervisé</li>
	<li>l'apprentissage par renforcement</li>
	<li>l'apprentissage évolutionniste</li>
	<li>la réduction de dimension</li>
	<li>les systèmes de recommandations</li>
</ul></p>

<p>Pour chacun de ces types de machine learning, le fonctionnement de quelques algorithmes sera présenté dans les sections suivantes.</p>

<p>L'<b>apprentissage supervisé</b> est utilisé pour la classification et la régression. A partir d'une base de données BDD d'apprentissage avec des données et leurs labels, il faut généraliser afin de donner un label à des données jamais vues. Nous avons par exemple une base de données contenant des images de chiffres manuscrits et le label de chaque image (à quel chiffre correspond chaque image). Avec un apprentissage supervisé, nous allons pouvoir apprendre à reconnaitre les chiffres manuscrits. Après la phase d'apprentissage, notre algorithme pourra déterminer avec un faible taux d'erreurs, le chiffre manuscrit présent sur une nouvelle image (qui n'appartient pas à la base de données d'apprentissage). Les principaux algorithmes supervisés sont les réseaux de neurones, le SVM, les arbres de décision (ID3, C5, CART) et la régression linéaire.</p>

<p>L'<b>apprentissage non supervisé</b> est utilisé pour partitionner les données (clustering) afin que les données dans une même partition soient proches entre elles (aient quelque chose en commun) et les données provenant de deux partitions différentes soient éloignées. Contrairement à l'apprentissage supervisé, la base de données d'apprentissage ne contient plus les labels. L'apprentissage non supervisé peut par exemple être utilisé pour regrouper les clients d'un magasin en différents groupes afin de faciliter le ciblage marketing. Les clients d'un même groupe aiment les mêmes produits. Les principaux algorithmes non supervisés sont le k-means, les algorithmes EM et le regroupement hiérarchique (basé sur la construction d'un arbre).</p>

<p>L'<b>apprentissage par renforcement</b> est un apprentissage d'un bon comportement à partir d'observations/récompenses. A chaque étape, l'algorithme propose une action et le système donne un score à cette action (indiquant si l'action est bénéfique ou pas) sans indiquer comment améliorer ce score. L'apprentissage par renforcement est par exemple utilisé pour créer des intelligences artificielles jouant au backgammon, aux échecs ou au go. Les principaux algorithmes d'apprentissage par renforcement sont le Q-learning et les algorithmes basés sur les Hidden Markov Models (Viterbi et Baum Welch).</p>

<p>L'<b>apprentissage évolutionniste</b> s'inspire de la théorie de l'évolution pour résoudre des problèmes divers. La théorie de l'évolution repose sur le fait que les organismes s'adaptent pour améliorer leur taux de survie et celui de leurs descendants. Les principaux algorithmes évolutionnistes sont les algorithmes génétiques et PBIL.</p>

<p>La <b>réduction de dimension</b> est utilisée pour réduire la dimension des données afin de réduire le stockage tout en gardant un maximum d'informations. La réduction de dimension peut aussi être utilisée pour garder uniquement les informations les plus intéressantes d'une base de données. Les principaux algorithmes de réduction de dimension sont LDA, PCA et ICA.</p>

<p>Le <b>système de recommandations</b> est un filtrage de l'information visant à présenter les éléments d'information (films, musique, livres, news, images, pages Web, etc) qui sont susceptibles d'intéresser un utilisateur. Les principaux algorithmes de recommandations sont le collaborative filtering, le content-based filtering et l'hybrid algorithm.</p>

<br>

<h4>Machine learning processus</h4>

<p>Pour la plupart des algorithmes de machine learning, le processus global de mise en place de l'apprentissage est similaire :
<ol>
	<li>Récupération et nettoyage des données</li>
	<li>Création des features</li>
	<li>Choix de l’algorithme</li>
	<li>Détermination des paramètres de l’algorithme</li>
	<li>Apprentissage</li>
	<li>Evaluation</li>
</ol>
</p>

<p>La base de données est généralement partitionnée en trois bases : 
<ul>
	<li>Base d’apprentissage (60%)</li>
	<li>Base de validation (20%)</li>
	<li>Base de test (20%)</li>
</ul></p>

<p>Tous les apprentissages sont effectués sur la base d'apprentissage, la performance de chaque apprentissage est validée sur la base de validation. La base de test est uniquement utilisée à la toute fin. Elle permet d'évaluer les performances de notre apprentissage en évitant le surapprentissage.</p>

<p>La méthode de <b>cross-validation</b> est une méthode d'estimation de la fiabilité d'un apprentissage qui limite le surapprentissage. Dans cette méthode, la base d’apprentissage (80%) est séparée en K sous-ensembles. Le premier sous-ensemble est utilisé pour la validation et les autres sous-ensembles sont utilisés pour l'apprentissage. Puis lors de l'apprentissage suivant, le 2e sous-ensemble est utilisé pour la validation et l'apprentissage est effectué sur les autres sous-ensembles. Et ainsi du suite, jusqu'à avoir effectué K apprentissages. Puis la moyenne des performances de chaque apprentissage est calculée pour estimer la performance globale de l'apprentissage.</p>

<br>

<h4>Quelques métriques</h4>

<p>Il existe différentes métriques pour évaluer les performances d'un apprentissage.</p>

<p>L'<b>accuracy </b> est égal au nombre d’entrées correctement classifiées sur le nombre total d’entrées.</p>

<p>La <b>matrice de confusion</b> est une matrice dont l’élément en position (i, j) est égal au nombre d’entrées que l’algorithme place dans la catégorie j alors qu’ils appartiennent à la catégorie i. Par conséquent, les valeurs au niveau de la diagonale de la matrice représentent le nombre d’éléments correctement classifiés. L’accuracy est donc égale à la somme des valeurs de la diagonale divisée par la somme de tous les éléments.</p>

 <p>La <b>sensibilité (recall), la spécificité (specificity) et la précision (precision)</b> sont calculées à partir de \(TP\) (resp. \(TN\) ) le nombre de vrais positifs (resp. négatifs) et de \(FP\) (resp. \(FN\)) le nombre de faux positifs (resp. négatifs):
  $$recall = TP/(TP + FN )$$
  $$specificity = TN/(TN + FP )$$
  $$precision = TP/(TP + FP )$$
 Par exemple, si nous cherchons à déterminer si un mail est un spam. Les vrais positifs sont les mails qui sont des spams et que l'algorithme classifie en spam. Les vrais négatifs sont les mails qui ne sont pas des spams et que l'algorithme classifie en non-spam. Les faux positifs sont les mails qui ne sont pas des spams mais que l'algorithme classifie en spam. Les faux négatifs sont les mails qui sont des spams mais que l'algorithme classifie en non-spam.
</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th></th>
      <th>Spam</th>
      <th>Non spam</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Classifié en spam (test positif)</th>
      <td>TP</td>
      <td>FP</td>
    </tr>
    <tr>
      <th>Classifié en non spam (test négatif)</th>
      <td>FN</td>
      <td>TN</td>
    </tr>
  </tbody>
</table>

<div class="text-center">
<img src="../../img/machinelearning/F1score.jpg" class="img-fluid" alt="F1score">
</div>

<p>Le <b>F1-score</b> est un score utilisant la précision et la sensibilité
$$2 \cdot precision \cdot recall/(precision + recall)$$
</p>

<p>La <b>courbe de ROC (Receiver Operator Characteristic)</b> est une courbe représentant le pourcentage de vrais positifs (sur l’axe y) par rapport au pourcentage de faux positifs (sur l’axe x). Cette courbe permet de comparer différents paramétrages d’un même classifieur ou de comparer différents classifieurs. L’aire sous la courbe ROC (area under the curve AUC) est une bonne métrique représentant le classifieur.</p>

<p>La <b>métrique de Minkowski</b> est égale à \(L_k(x,y)=\sum _i (|x_i - y_i |^k)^{1/k}\). Si k = 1, elle correspond à la distance de Manhattan. Si k = 2, elle correspond à la distance Euclidienne.</p>

